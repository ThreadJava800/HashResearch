# Хеш-таблица
>  Хеш-таблица методом списков с различными видами оптимизаций
## Содержание
1. [Общая информация](#general)
2. [Сравнение хеш-функций](#cmp)
3. [Оптимизации](#optims)
    1. [Сравнение строк](#optim1)
    2. [Хеш-функция](#optim2)

## Общая информация <a name="general"></a>
Целью работы было написать хеш-таблицу методом списков и оптимизировать функцию поиска различными способами.\
Для тестов использовался датасет с англо-русским словарём, взятый с [kaggle](https://www.kaggle.com/datasets/hijest/englishrussian-dictionary-for-machine-translate), в котором предварительно были удалены все дубликаты. В итоге получилось ~ 250.000 строк.\
Стоит отметить, что в датасете помимо одиночных слов могут встречаться и цельные предложения.

## Сравнение хеш-функций <a name="cmp"></a>
Чтобы поиск по хеш-таблице был наиболее эффективным, нужно выбрать наиболее равномерный хеш-алгоритм. Для этого я взял 6 хеш-функций, для каждой из которой посчитал среднеквадратичное отклонение.

*Для хеш-таблицы все значения хеш-функций берутся по модулю 127.*

### Константый хеш
```C
uint64_t numberHash (const char *string) {
    return 1;
}
```
Это просто функция, возвращающая единицу на любом входе. Очевидно, что равномерности от неё ожидать не стоит (тем более, по модулю 127). Это видно из графика:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/constHash.png)
|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |

### ASCII-хеш
Данная хеш-функция возвращает ASCII-код первого символа в строке:
```C
uint64_t asciiHash (const char *string) {
    return (uint64_t) string[0];
}
```
|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |

Отклонение по-прежнему остаётся большим, относительно суммарного количества элементов.\
Данный результат соответствует ожиданиям, т.к. в английском языке всего 26 букв.\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/asciiHash.png)

### Длина строки как хеш-функция
```C
uint64_t lenHash (const char *string) {
    return (uint64_t) strlen(string);
}
```
Этот хеш гораздо лучше остальных, учитывая, что длина некоторых строк у меня превосходит 100. Однако, подавляющее большинство элементов имеют длины по 20-40 символов, в результате чего в этой области наблюдается скопление.\
Стоит отметить, что для одиночных слов этот хеш будет работать хуже, т.к. их длины будут гораздо меньше, чем длины отдельных предложений.
|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |
| Длина строки | 3237.4 | 1977.7 | 251171 |

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/lenHash.png)

### ROR, ROL и GNU
В качестве более жизнеспособного хеша я взял GNU-hash, умножающий хеш на простое число и прибавляющий к нему ASCII-код очередного символа:
```C
uint64_t gnuHash   (const char *string) {
    uint64_t hash = DEFAULT_GNU_HASH;

    while (*string != '\0')
    {
        hash = hash * 3 + (uint64_t) *string;

        string++;
    }

    return hash;
}
```

Также были рассмотрены ROL и ROR хеши, которые похожи по своему функционалу, который сдвигает влево (вправо) хеш и делает xor его с очередным ASCII-кодом символа.
```C
uint64_t rotrHash  (const char *string) {
    uint64_t hash = 0;

    while (*string != '\0')
    {
        hash = rotr(hash) ^ (*string);

        string++;
    }
    
    return hash;
}
```

Для начала сравним ROR и GNU хеши, и определим лучшего.

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/RorGnu.png)

|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |
| Длина строки | 3237.4 | 1977.7 | 251171 |
| ROR-хеш | 49.7 | 1977.7 | 251171 |
| GNU-хеш | 44.6 | 1977.7 | 251171 |

Теперь сравним ROR и ROL.

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/RorRol.png)

|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |
| Длина строки | 3237.4 | 1977.7 | 251171 |
| ROR-хеш | 49.7 | 1977.7 | 251171 |
| GNU-хеш | 44.6 | 1977.7 | 251171 |
| ROL-хеш | 44.3 | 1977.7 | 251171 |

Общее сравнение GNU, ROL и ROR:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/gnuRolRor.png)

По результатам замеров, вышло, что ROL-хеш показал себя лучше на этих данных, чем остальные хеши.\
Однако также не стоит забывать про производительность этих хеш-функций. В нашем случае, с большим объёмом данных, это немаловажно.\
Было замерено время работы ROR, ROL, и GNU-хешей для $10^8$ элементов:
|  Хеш функция | Время работы |
|---|---|
| ROR-хеш | 27 870.3 ± 18.6 ms |
| GNU-хеш | 39 476.0 ± 17.0 ms |
| ROL-хеш | 26 543.3 ± 18.9 ms |

Исходя из полученных результатов, в дальнейшем будем использовать ROL-хеш для таблицы.

## Оптимизации <a name="optims"></a>
Сначала была реализована наивная версия хеш-таблицы (без оптимизаций). Хеш-таблица представляет из себя массив [двусвязных <em>cache-friendly</em> списков](https://github.com/ThreadJava800/LinkedList). Для каждого ключа высчитывается его хеш-функция и берётся по модулю размера массива со списками. Затем по полученному индексу извлекается список, в который кладётся значение. В моем случае в списке хранится структура с ключом и значением.\
Основной целью было оптимизировать функцию поиска по ключу в хеш-таблице, наивная версия которой работает дольше, чем хотелось бы.\
Для измерения времени было выполнено $10^5$ поисков по хеш-таблице.

*Программа была скомпилирована с флагом оптимизации `-O1`. Во время тестов других программ запущено не было.*

|  Оптимизация | Время работы $10^5$ поисков | Ускорение |
|---|---|---|
| - | 2155.8 ± 63.5 ms | baseline |

Для поиска т.н. "узких мест" я использовал профайлер [Perf](https://perf.wiki.kernel.org/index.php/Main_Page) и GUI [Hotspot](https://github.com/KDAB/hotspot) для него.\
Программа указала, что основное проблемное место - в функции сравнения строк:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/perf1.png)


### Сравнение строк <a name="optim1"></a>
Для начала я решил посмотреть, какой ассемблерный код генерирует `-O1` для функции сравнения. `-O1` хорошо оптимизирует код, однако всё равно нашлось место для оптимизации.

Код на Си:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/strcmp1.png)\
Ассемблерный код с `-O1`:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/strcmp2.png)

Моя версия:
```asm
    cmp al, 0
    je _retNeg

_retNeg:
    cmp al, cl
    je _ret0

    mov eax, 1
    ret
```

Тем не менее, после этих оптимизаций время работы не изменилось (с учётом погрешности).
|  Оптимизация | Время работы $10^6$ сравнений | Ускорение |
|---|---|---|
| `-O1` | 278.6 ± 1.9 ms | baseline |
| ASM версия | 280.8 ± 1.6 ms | 1x |

Далее было принято решение переписать данную при помощи интринсиков. Таким образом, я смог сравнивать 32 символа за раз (AVX-инструкции). Для того, чтобы не проверять на окончание строки в функции сравнения, я теперь храню длину ключа в списке, наряду с ключом и значением.
|  Оптимизация | Время работы $10^6$ сравнений | Ускорение |
|---|---|---|
| `-O1` | 278.6 ± 1.9 ms | baseline |
| ASM версия | 280.8 ± 1.6 ms | 1x |
| Intrinsic версия | 216.4 ± 1.9 ms | 1.3x |

По итогу общее время поиска ускорилось почти в 4 раза.
|  Оптимизация | Время работы $10^5$ поисков | Ускорение |
|---|---|---|
| - | 2155.8 ± 63.5 ms | baseline |
| Функция сравнения | 542.4 ± 5.9 ms | 4x |

И по итогу в профайлере функция опустилась ниже:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/perf2.png)

### Хеш-функция <a name="optim2"></a>
Как можно видеть в профайлере, следующая функция, относящаяся к поиску - хеш-функция (`rotlHash()`).

Её я решил переписать при помощи ассемблерной вставки. Обратимся к godbolt.org:\
(Флаг компиляции `-O1`):\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/optim2.png)\
Как можем видеть, `g++` генерирует несколько сравнений, когда можно обойтись одним. Напишем собственную реализацию этого хеш-алгоритма:
```asm
mrotlHash:
    xor rax, rax    ; rax = 0 (hash)

.rotlLoop:
    movb rcx, byte [rdi]

    rol rax, 1
    xor rax, rcx
    inc rdi

    cmp byte [rdi], 0
    jne .rotlLoop

    ret
```
В результате удалось получить ускорение в 1.05х:
|  Оптимизация | Время работы $10^6$ вызовов | Ускорение |
|---|---|---|
| `-O1` | 279.4 ± 0.5 ms | baseline |
| ASM версия | 266.0 ± 0.9 ms | 1.05x |

Ускорения не является сильным, однако другие оптимизации здесь использовать нецелесообразно. Например, использовать интринсики здесь будет невыгодно из-за зависимости каждой итерации цикла от предыдущей.

Примечательно, что `-O1` смог понять, что делает функция rotl:
```C
uint64_t rotl(uint64_t value) {
    return (value << 1) | (value >> 63);
}
```
И сгенерировать следующий ассемблерный код по ней:
```asm
mov     rax, rdi
rol     rax
ret
```
Более того, `-O1` её автоматически инлайнит:\
Код на Си:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/cCode.png)\
Код на ассемблере:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/asmCode.png)

По итогу функция поиска ускорилась в 1.03 раза:
|  Оптимизация | Время работы $10^5$ поисков | Ускорение |
|---|---|---|
| - | 2155.8 ± 63.5 ms | baseline |
| Функция сравнения | 542.4 ± 5.9 ms | 4x |
| Оптимизация хеша | 525.4 ± 3.0 ms | 1.03x |