# Хеш-таблица
>  Хеш-таблица методом списков с различными видами оптимизаций
## Содержание
1. [Общая информация](#general)
2. [Сравнение хеш-функций](#cmp)

## Общая информация <a name="general"></a>
Целью работы было написать хеш-таблицу методом списков и оптимизировать функцию поиска различными способами.\
Для тестов использовался датасет с англо-русским словарём, взятый с [kaggle](https://www.kaggle.com/datasets/hijest/englishrussian-dictionary-for-machine-translate), в котором предварительно были удалены все дубликаты. В итоге получилось ~ 250.000 строк.\
Стоит отметить, что в датасете помимо одиночных слов могут встречаться и цельные предложения.

## Сравнение хеш-функций <a name="cmp"></a>
Чтобы поиск по хеш-таблице был наиболее эффективным, нужно выбрать наиболее равномерный хеш-алгоритм. Для этого я взял 6 хеш-функций, для каждой из которой посчитал среднеквадратичное отклонение.

*Для хеш-таблицы все значения хеш-функций берутся по модулю 127.*

### Константый хеш
```C
uint64_t numberHash (const char *string) {
    return 1;
}
```
Это просто функция, возвращающая единицу на любом входе. Очевидно, что равномерности от неё ожидать не стоит (тем более, по модулю 127). Это видно из графика:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/constHash.png)
|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |

### ASCII-хеш
Данная хеш-функция возвращает ASCII-код первого символа в строке:
```C
uint64_t asciiHash (const char *string) {
    return (uint64_t) string[0];
}
```
|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |

Отклонение по-прежнему остаётся большим, относительно суммарного количества элементов.\
Данный результат соответствует ожиданиям, т.к. в английском языке всего 26 букв.\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/asciiHash.png)

### Длина строки как хеш-функция
```C
uint64_t lenHash (const char *string) {
    return (uint64_t) strlen(string);
}
```
Этот хеш гораздо лучше остальных, учитывая, что длина некоторых строк у меня превосходит 100. Однако, подавляющее большинство элементов имеют длины по 20-40 символов, в результате чего в этой области наблюдается скопление.\
Стоит отметить, что для одиночных слов этот хеш будет работать хуже, т.к. их длины будут гораздо меньше, чем длины отдельных предложений.
|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |
| Длина строки | 3237.4 | 1977.7 | 251171 |

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/lenHash.png)

### ROR, ROL и GNU
В качестве более жизнеспособного хеша я взял GNU-hash, умножающий хеш на простое число и прибавляющий к нему ASCII-код очередного символа:
```C
uint64_t gnuHash   (const char *string) {
    uint64_t hash = DEFAULT_GNU_HASH;

    while (*string != '\0')
    {
        hash = hash * 3 + (uint64_t) *string;

        string++;
    }

    return hash;
}
```

Также были рассмотрены ROL и ROR хеши, которые похожи по своему функционалу, который сдвигает влево (вправо) хеш и делает xor его с очередным ASCII-кодом символа.
```C
uint64_t rotrHash  (const char *string) {
    uint64_t hash = 0;

    while (*string != '\0')
    {
        hash = rotr(hash) ^ (*string);

        string++;
    }
    
    return hash;
}
```

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/RorGnu.png)

|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |
| Длина строки | 3237.4 | 1977.7 | 251171 |
| ROR-хеш | 49.7 | 1977.7 | 251171 |
| GNU-хеш | 44.6 | 1977.7 | 251171 |

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/RorRol.png)

|  Хеш функция | Отклонение | Среднее значение | Количество элементов |
|---|---|---|---|
| Константный хеш | 22199.9 | 1977.7 | 251171 |
| ASCII-хеш | 10021.1 | 1977.7 | 251171 |
| Длина строки | 3237.4 | 1977.7 | 251171 |
| ROR-хеш | 49.7 | 1977.7 | 251171 |
| GNU-хеш | 44.6 | 1977.7 | 251171 |
| ROL-хеш | 44.3 | 1977.7 | 251171 |

По результатам замеров, вышло, что ROL-хеш показал себя лучше на этих данных, чем остальные хеши.\
Однако также не стоит забывать про производительность этих хеш-функций. В нашем случае, с большим объёмом данных, это немаловажно.\
Было замерено время работы ROR, ROL, и GNU-хешей для $10^8$ элементов:
|  Хеш функция | Время работы |
|---|---|
| ROR-хеш | 27 870.3 ± 18.6 ms |
| GNU-хеш | 39 476.0 ± 17.0 ms |
| ROL-хеш | 26 543.3 ± 18.9 ms |

Исходя из полученных результатов, в дальнейшем будем использовать ROL-хеш для таблицы.