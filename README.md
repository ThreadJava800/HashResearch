# Хеш-таблица
>  Хеш-таблица методом списков с различными видами оптимизаций
## Содержание
1. [Общая информация](#general)
2. [Сравнение хеш-функций](#cmp)
3. [Оптимизации](#optims)
    1. [Поиск длины строки](#optim1)
    2. [Сравнение строк](#optim2)
    3. [Хеш-функция](#optim3)
4. [Вывод](#res)

## Общая информация <a name="general"></a>
Целью работы было написать хеш-таблицу методом списков и оптимизировать функцию поиска различными способами.\
Для тестов использовался датасет с англо-русским словарём, взятый с [kaggle](https://www.kaggle.com/datasets/hijest/englishrussian-dictionary-for-machine-translate), в котором предварительно были удалены все дубликаты. В итоге получилось ~ 250.000 строк.\
Стоит отметить, что в датасете помимо одиночных слов могут встречаться и цельные предложения.

## Сравнение хеш-функций <a name="cmp"></a>
Чтобы поиск по хеш-таблице был наиболее эффективным, нужно выбрать наиболее равномерный хеш-алгоритм. Для этого я взял 6 хеш-функций, для каждой из которой посчитал среднеквадратичное отклонение.

*Для хеш-таблицы все значения хеш-функций берутся по модулю размера массива со списками (= 127).*

### Константный хеш
```C
uint64_t numberHash (const char *string) {
    return 1;
}
```
Это просто функция, возвращающая единицу на любом входе. Очевидно, что равномерности от неё ожидать не стоит. Это видно из графика:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/constHash.png)
|  Хеш функция | Отклонение (кол-во элементов) |
|---|---|
| Константный хеш | 22199.9 |

### ASCII-хеш
Данная хеш-функция возвращает ASCII-код первого символа в строке:
```C
uint64_t asciiHash (const char *string) {
    return (uint64_t) string[0];
}
```
|  Хеш функция | Отклонение (кол-во элементов) |
|---|---|
| Константный хеш | 22199.9 |
| ASCII-хеш | 10021.1 |

Отклонение по-прежнему остаётся большим, относительно суммарного количества элементов.\
Данный результат соответствует ожиданиям, т.к. в английском языке всего 26 букв.\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/asciiHash.png)

### Длина строки как хеш-функция
```C
uint64_t lenHash (const char *string) {
    return (uint64_t) strlen(string);
}
```
Этот хеш гораздо лучше остальных, учитывая, что длина некоторых строк у меня превосходит 100. Однако, подавляющее большинство элементов имеют длины по 20-40 символов, в результате чего в этой области наблюдается скопление.\
Стоит отметить, что для одиночных слов этот хеш будет работать хуже, т.к. их длины будут гораздо меньше, чем длины отдельных предложений.
|  Хеш функция | Отклонение (кол-во элементов) |
|---|---|
| Константный хеш | 22199.9 |
| ASCII-хеш | 10021.1 |
| Длина строки | 3237.4 |

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/lenHash.png)

### ROR, ROL и GNU
В качестве более жизнеспособного хеша я взял GNU-hash, умножающий хеш на простое число и прибавляющий к нему ASCII-код очередного символа:
```C
uint64_t gnuHash   (const char *string) {
    uint64_t hash = DEFAULT_GNU_HASH;

    while (*string != '\0')
    {
        hash = hash * 3 + (uint64_t) *string;

        string++;
    }

    return hash;
}
```

Также были рассмотрены ROL и ROR хеши, которые похожи по своему функционалу, который сдвигает влево (вправо) хеш и делает xor его с очередным ASCII-кодом символа.
```C
uint64_t rotrHash  (const char *string) {
    uint64_t hash = 0;

    while (*string != '\0')
    {
        hash = rotr(hash) ^ (*string);

        string++;
    }
    
    return hash;
}
```

Для начала сравним ROR и GNU хеши, и определим лучшего.

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/RorGnu.png)

|  Хеш функция | Отклонение (кол-во элементов) |
|---|---|
| Константный хеш | 22199.9 |
| ASCII-хеш | 10021.1 |
| Длина строки | 3237.4 |
| ROR-хеш | 49.7 |
| GNU-хеш | 44.6 |

Теперь сравним GNU и ROL.

![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/RorRol.png)

|  Хеш функция | Отклонение (кол-во элементов) |
|---|---|
| Константный хеш | 22199.9 |
| ASCII-хеш | 10021.1 |
| Длина строки | 3237.4 |
| ROR-хеш | 49.7 |
| GNU-хеш | 44.6 |
| ROL-хеш | 44.3 |

Общее сравнение GNU, ROL и ROR:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/gnuRolRor.png)

По результатам замеров, вышло, что ROL-хеш показал себя лучше на этих данных, чем остальные хеши.\
Однако также не стоит забывать про производительность этих хеш-функций. В нашем случае, с большим объёмом данных, это немаловажно.\
Было замерено время работы ROR, ROL, и GNU-хешей для $10^8$ элементов:
|  Хеш функция | Время работы (мс) |
|---|---|
| ROR-хеш | 27 870.3 ± 18.6 |
| GNU-хеш | 39 476.0 ± 17.0 |
| ROL-хеш | 26 543.3 ± 18.9 |

Исходя из полученных результатов, в дальнейшем будем использовать ROL-хеш для таблицы.

## Оптимизации <a name="optims"></a>
Сначала была реализована наивная версия хеш-таблицы (без оптимизаций). Хеш-таблица представляет из себя массив [двусвязных <em>cache-friendly</em> списков](https://github.com/ThreadJava800/LinkedList). Для каждого ключа высчитывается его хеш-функция и берётся по модулю размера массива со списками. Затем по полученному индексу извлекается список, в который кладётся значение. В моем случае в списке хранится структура с ключом и значением.\
Основной целью было оптимизировать функцию поиска по ключу в хеш-таблице, наивная версия которой работает дольше, чем хотелось бы.\
Для измерения времени было выполнено $10^5$ поисков по хеш-таблице.

*Программа была скомпилирована с флагом оптимизации `-O1`. Во время тестов других программ запущено не было.*

|  Оптимизация | Время работы $10^5$ поисков (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 2027.6 ± 50.9 | baseline | baseline |

Для поиска т.н. "узких мест" я использовал профайлер [perf](https://perf.wiki.kernel.org/index.php/Main_Page) и GUI [hotspot](https://github.com/KDAB/hotspot) для него.\
Программа указала, что основное проблемное место - в функции сравнения строк:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/hotspot1.png)

### Поиск длины строки <a name="optim1"></a>
Отсечь большое количество проверок можно зная длину строки (если длины двух строк не равны, то они заведомо не совпадают). Для этого, в списке, наряду с ключом и значением, будем хранить длину ключа. Таким образом, начнём с оптимизации поиска длины строки.\
Так эта функция представляется в ассемблере (флаг `-O1`)\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/optim3.png)\
Эту функцию можно переписать лучше на ассемблере (вместо 10 ассемблерных команд обойтись лишь 8):
```asm
mstrlen:
    mov rsi, rdi    ; rdi - string

__strlenLoop:
    lodsb           ; byte [rsi] -> al
    
    cmp al, 0x00
    je __exit

    inc rcx         ; symb cnt
    jmp __strlenLoop

__exit:
    mov rax, rcx    ; return data
    ret
```
Однако, функция быстрее работать быстрее не стала. Это связано с особенностями моего процессора (AMD Zen 3). Согласно [таблице инструкций](https://www.agner.org/optimize/instruction_tables.pdf):
|  Команда процессора | Throughput |
|---|---|
| lods | 3 |
| cmp (mem, i) | 0.33 |

Таким образом, версия с прямым сравнением числа из памяти с int-ом работает быстрее, чем предварительная загрузка из памяти в регистр, а затем сравнение регистра с int.

Поэтому была реализована ещё одна версия на ассемблере:
```asm
mstrlen:
    xor eax, eax
    cmp byte [rdi], 0
    je .leave

.mstrloop:
    inc rax
    cmp byte [rdi + rax], 0
    jne .mstrloop

.leave:
    ret
```

|  Оптимизация | Время работы $10^6$ вызовов (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 145.6 ± 7.2 | baseline | baseline |
| ASM (lodsb) | 409.2 ± 0.4 | 0.36x | 0.36x |
| ASM (cmp m,i) | 141.2 ± 0.66 | 2.9x | 1.03x |

Далее была предпринята попытка переписать эту функцию на интринсиках. Тем не менее, в процессе было выяснено, что реализация стандартной функции strlen уже использует avx оптимизации. После необходимых измерений получились следующие результаты:
|  Оптимизация | Время работы $10^6$ вызовов (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 145.6 ± 7.2 | baseline | baseline |
| ASM (lodsb) | 409.2 ± 0.4 | 0.36x | 0.36x |
| ASM (cmp m,i) | 141.2 ± 0.66 | 2.9x | 1.03x |
| Стандартная функция | 0.39 ± 0.03 | 362x | 373x |


Таким образом, за счёт использования стандартной функции, скорость работы функции поиска изменилась следующим образом:
|  Оптимизация | Время работы $10^5$ поисков (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 2027.6 ± 50.8 | baseline | baseline |
| Длина строки | 2004.2 ± 45.5 | 1.01x | 1.01x |

Сильного ускорения и не ожидалось, т.к. эта функция вызывается всего один раз в функции поиска.

### Сравнение строк <a name="optim2"></a>
Сперва была реализована наивная версия сравнения строк на С.

Для начала я решил посмотреть, какой ассемблерный код генерирует `-O1` для функции сравнения. `-O1` хорошо оптимизирует код, однако всё равно нашлось место для оптимизации.

Код на Си:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/strcmp1.png)\
Ассемблерный код с `-O1`:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/strcmp2.png)

Я решил обойтись ассемблерными строковыми функциями, таким образом уменьшив количество проверок.
```asm
strcmp:
    xor rax, rax
    cmp rcx, rdx
    jne .difLens

    cld                 ; clean df

    repe cmpsb      
    je .notEq
    jmp .exit

.notEq:
    mov al, byte [rdi]
    sub al, byte [rsi]
    jmp .exit           ; return [rdi]-[rsi]

.difLens:
    mov rax, rcx
    sub rax, rdx        ; return dif between length

.exit:
    ret
```

Однако снова программа не ускорилась, опять же из-за особенностей процессора:\
*n - количество символов в строке*
|  Команда процессора | Throughput |
|---|---|
| rep cmps | 3n |
| mov (r, m8) | 0.33 |
| cmp (r, m) | 0.33 |
| inc | 0.25 |
| loop | 0.5-1 |

Таким образом версия с загрузкой из памяти, сравнением, двумя инкрементами и циклом будет работать быстрее, чем версия со строковыми функциями (т.к. $(0.33 + 0.33 + 2 * 0.25 + 1) * n = 2.16n ≤ 3n$):

strcmpLoop изменится следующим образом:
```asm
.strcmpLoop:
    mov al, byte [rdi]
    cmp al, byte [rsi]
    jne .notEq

    inc rdi
    inc rsi
    loop .strcmpLoop
```

Таким образом:
|  Оптимизация | Время работы $10^6$ сравнений (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 411.0 ± 8.0 | baseline | baseline |
| ASM (стр. ф-ии) | 415.0 ± 6.54 | 0.99x | 0.99x |
| ASM (вер. 2) | 269.2 ± 0.4 | 1.54x | 1.53x |

Далее было принято решение переписать данную при помощи интринсиков. Таким образом, я смог сравнивать 32 символа за раз (AVX-инструкции). Т.к. мы храним длину ключа, у нас нет необходимости отдельно проверять кончилась ли строка, или нет.

Таким образом сравниваются символы (str1 и str2 - `__m256i` переменная с 32 символами):
```C
int cmpMask = _mm256_extract_epi32(_mm256_cmpeq_epi8(str1, str2), 0);

if (cmpMask != 0xFFFFFFFF) return -1;
```

|  Оптимизация | Время работы $10^6$ сравнений (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 411.0 ± 8.0 | baseline | baseline |
| ASM (стр. ф-ии) | 415.0 ± 6.54 | 0.99x | 0.99x |
| ASM (вер. 2) | 269.2 ± 0.4 | 1.54x | 1.53x |
| Интринсики | 204.6 ± 1.36 | 1.32x | 2x |

По итогу общее время поиска ускорилось в 3.7 раза.
|  Оптимизация | Время работы $10^5$ поисков (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 2027.6 ± 50.8 | baseline | baseline |
| Длина строки | 2004.2 ± 45.5 | 1.01x | 1.01x |
| Сравнение строк | 542.2 ± 2.5 | 3.70x | 3.74x |

И по итогу в профайлере функция опустилась ниже:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/hotspot2.png)

### Хеш-функция <a name="optim3"></a>
Как можно видеть в профайлере, следующая функция, относящаяся к поиску - хеш-функция (`rotlHash()`).

Её я решил переписать при помощи ассемблерной вставки. Обратимся к godbolt.org:\
(Флаг компиляции `-O1`):\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/optim2.png)\
Как можем видеть, `g++` генерирует несколько сравнений, когда можно обойтись одним. Напишем собственную реализацию этого хеш-алгоритма:
```asm
mrotlHash:
    xor rax, rax    ; rax = 0 (hash)

.rotlLoop:
    movb rcx, byte [rdi]

    rol rax, 1
    xor rax, rcx
    inc rdi

    cmp byte [rdi], 0
    jne .rotlLoop

    ret
```

Подключим эту функцию через отдельный файл и получим следующее ускорение:
|  Оптимизация | Время работы $10^6$ вызовов (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 278.4 ± 9.0 | baseline | baseline | 
| ASM (file) | 275.0 ± 0.63 | 1.01x | 1.01x |

Также стоит отметить, что ассемблерная функция, находящаяся в другом файле, не всегда инлайнится (в то время как функция с ассемблерной вставкой - инлайнится). Это видно из тестов:

|  Оптимизация | Время работы $10^6$ вызовов (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 278.4 ± 9.0 | baseline | baseline | 
| ASM (file) | 275.0 ± 0.63 | 1.01x | 1.01x |
| ASM (inline) | 265.2 ± 0.36 | 1.04x | 1.05x |

Ускорения не является сильным, однако другие оптимизации здесь использовать нецелесообразно. Например, использовать интринсики здесь будет невыгодно из-за зависимости каждой итерации цикла от предыдущей.

Примечательно, что `-O1` смог понять, что делает функция rotl:
```C
uint64_t rotl(uint64_t value) {
    return (value << 1) | (value >> 63);
}
```
И сгенерировать следующий ассемблерный код по ней:
```asm
mov     rax, rdi
rol     rax
ret
```
Более того, `-O1` её автоматически инлайнит:\
Код на Си:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/cCode.png)\
Код на ассемблере:\
![Const](https://github.com/ThreadJava800/HashResearch/blob/main/readmepics/asmCode.png)

По итогу функция поиска ускорилась в 1.14 раза:
|  Оптимизация | Время работы $10^5$ поисков (мс) | Относительное ускорение | Абсолютное ускорение |
|---|---|---|---|
| - | 2027.6 ± 50.8 | baseline | baseline |
| Длина строки | 2004.2 ± 45.5 | 1.01x | 1.01x |
| Сравнение строк | 542.2 ± 2.5 | 3.70x | 3.74x |
| Хеш-функция | 476.2 ± 2.5 | 1.14x | 4.26x |

## Вывод <a name="res"></a>
Как показывает практика, использование интринсиков является наиболее эффективным методом оптимизации из всех рассмотренных в этой работе. Поэтому ассемблерные оптимизации следует рассматривать в последнюю очередь, например, если написание функции с интринсиками трудозатратно или если они неприменимы.